# **포인터와 참조 타입**
## **Go에서의 포인터란?**
- **C & C++** vs **Python & C#** vs **Go**
    - **C와 C++** 에서는 **포인터**로 **메모리 주소**를 **직접 제어**할 수 있다.
    - 하지만 이는 **코드의 가독성과 안정성**을 떨어뜨린다.
    - 따라서 **C#이나 Python**는 포안터를 사용하지 않고 **객체 참조 방식**으로 **메모리에 접근**한다.
    - **Go**는 **포인터**와 **참조 타입**을 모두 제공한다.

- **슬라이스, 맵, 채널, 함수, 메서드**는 **참조 타입**이다.
- 또한 **Go**에서 **포인터**는 값에 **접근하는 수단**일 뿐, 주소 값을 직접 변경할 수는 없다.

<br>

---
## **포인터 생성과 초기화**
- 포인터 변수는 **타입 앞에 * 연산자**를 표기하여 선언한다.
    ~~~go
    type rect struct{w, h float64}

    var pRect *rect
    var pInt *int
    var pFloat *float64
    var pComplex *complex128
    ~~~

- **포인터**는 다음 **두 가지 방식**으로 선언한다.
    - **주소 연산자**(&)로 특정 값의 메모리 주소를 **포인터 변수에 할당**
        1. 변수 앞에 **주소 연산자**(&)를 붙이면 **변수의 주소**를 알아낼 수 있다.
        2. 그리고 그 주소 값을 **변수에 할당**해서 사용할 수 있다.
        ~~~go
        var p *int
        i := 1
        p = &i
        fmt.Println(i)	// 1
        fmt.Println(&i)	// 0xc00001a1e8
        fmt.Println(*p)	// 1
        fmt.Println(p)	// 0xc00001a1e8
        ~~~

        - 또한 **선언과 동시에 초기화**하는 코드를 작성할 수도 있다.
        ~~~go
        type rect struct {
            w, h float64
        }

        var i int = 1
        var p *int = &i
        var s *rect = &rect{1, 2}

        fmt.Println(p)
        fmt.Println(s)
        ~~~
        ~~~
        실행 결과

        0xc00001a1d0
        &{1 2}
        ~~~

    - **new()함수**로 메모리를 초기화 한 후 **포인터 변수에 할당**
        1. **new 함수** 사용 -> 매개변수로 전달한 타입에 맞는 **메모리 공간 초기화** -> **주소 반환**
        2. 이 반환된 메모리 주소를 **포인터 변수에 할당**해서 사용할 수 있다.

        <br>

        - **정수 포인터를 new()로 생성**
        ~~~go
        p := new(int)
        *p = 1
        fmt.Println(p)  // 0xc00001a1d8
        fmt.Println(*p) // 1
        ~~~
        - **구조체 포인터를 new()로 생성**
        ~~~go
        r := new(rect)
        r.w, r.h = 3, 4
        fmt.Println(r)  // &{3, 4}
        fmt.Println(*r) // {3, 4}
        ~~~